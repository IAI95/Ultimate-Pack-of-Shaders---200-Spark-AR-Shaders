float sdPlane(vec3 p, std::Texture2d Texture)
{
    vec2 iResolution = std::getRenderTargetSize();
    float width = .4; // Width of the tile
    float tiling = 15.; // Grid precision
    
    vec2 idx = floor(p.xy*tiling);
    vec2 str = vec2(iResolution.y/iResolution.x, 1); 
    float h = length(Texture.sample(str*idx/(2.*tiling)+.5).xyz)/7.;
    //shapable tile
    vec2 f = fract(p.xy*tiling)-.5; // centering
    float N = 4.; // 1. for losange 2. circle  +inf for square (L-N distances)
    float l = pow( pow(abs(f.x), N) + pow(abs(f.y), N), 1./N);
        
    return h*smoothstep(0., 0.05, width-l);
}


float castray(vec3 ro, vec3 rd, std::Texture2d Texture)
{
  vec3 p;
  float dt, depth;
  
  float t = .05*fract(sin(dot(rd, vec3(125.45, 213.345, 156.2001)))); // dithering
  for (float d = .5; d < 2.4; d += .004) { // lower value for d induce better results but more costly
    p = ro + rd*(d+t);
    float depth = sdPlane(p, Texture);
    if (p.z < depth){
        break;}
      }
  return p.z;
}


void mainImage( in std::Texture2d Texture, out vec4 Return )
{

    vec2 iResolution = std::getRenderTargetSize();
    vec2 fragCoord = fragment(floor(std::getRenderTargetSize() * std::getVertexTexCoord()));
    float Time = std::getTime();

    vec2 st = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;

    vec3 ro = vec3(0, 0, 1); // ray origin 
    vec3 rd = normalize(vec3(st, -1)); // ray direction

    float d = castray(ro, rd, Texture);
	  Return = vec4(vec3(d)*5., 1.);
}